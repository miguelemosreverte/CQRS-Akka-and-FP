<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Welcome file</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><h1 id="diagram-of-a-cat-jump">Diagram of a cat jump</h1>
<p>During the years, the cat jump reflex was a phenomena that intrigued the population. They always fell on their feet.<br>
This is <strong>the oldest recording we have of such phenomena</strong>, captured in 1894.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/7/7f/Falling_cat_1894.jpg" alt="enter image description here"></p>
<p>In this project, we are going to make the equivalent of a <strong>cat jump</strong>.<br>
That is, we are going to implement an arquitecture using OOP, for then pivot to FP.</p>
<p>Let’s hope that we land on our feet.</p>
<h1 id="the-architecture">1 - The Architecture</h1>
<p>This is a CQRS diagram, summarized by text:</p>
<ol>
<li>Data comes in</li>
<li>We split the data into it’s most atomic expressions
<ul>
<li>using DomainDrivenDesign as a guide:
<ul>
<li>we are looking for <em>value objects</em>, and <em>entities</em></li>
</ul>
</li>
</ul>
</li>
<li>It is routed to processors [writeside]
<ul>
<li>this processors are stateful and recover from failure</li>
<li>this processors use Event Sourcing to recover from failure</li>
</ul>
</li>
<li>We react to this events to create an aggregation (ie.: the sum, the average)
<ul>
<li>using DomainDrivenDesign as a guide:
<ul>
<li>now we are looking for <em>aggregates</em></li>
</ul>
</li>
</ul>
</li>
<li>We store this aggregations to a query-friendly database [readside]</li>
</ol>
<p>Now this is the same, but as a painting.<br>
<img src="https://i.imgur.com/WgEohXU.png" alt="enter image description here"></p>
<p>This architecture can be implemented in many ways, no need to couple to any paradigm or framework to do so. After all, it was invented a while ago. Not in 1894 as in the photo of the jumping cat, mind you, but very old and known in terms of CS history.</p>
<blockquote></blockquote>
<pre><code>CQRS was invented when performance was an issue, (still is), and to avoid system overload the entire system was split into two: The writeside, were the most transactional bussiness logic was placed, and then the conclusions, which could take their time to be computed, as it ussually did at the time. (And for some reason, as of 2020, still does).
It is true that even though computers have gotten stronger with the passage of time, our hunger for conclusions has all but decreased. 
Software, someone wiser once said, expands like gas to fill any container, no matter the size. And because of this principle is that we are still talking about CQRS on 2020. Because of performance.
</code></pre>
<p>CQRS means to not block the input of data, to let it come in without throttle. Because it will be <em>then</em> when we will aggregate it’s values to achieve a conclusion.</p>
<p>Until then fullfill those transactions as fast as you can!<br>
<em>Don’t let anyone block you!</em></p>
<p>That is, if I can be concise about it, my definition for CQRS.</p>
<p>Now, let’s cut the talk and let’s talk bussiness.</p>
<h1 id="the-bussiness">2- The Bussiness</h1>
<p>Our domain is going to be about the GDP of countries. How much they earn yearwise.</p>
<p>To do this we are going to have:</p>
<ol>
<li>Entities
<ul>
<li>Country</li>
</ul>
</li>
<li>Value Objects
<ul>
<li>GDP</li>
</ul>
</li>
</ol>
<p>We are going to rank them, this is an aggregation.</p>
<ol start="3">
<li>Aggregates
<ul>
<li>TopTenCountries</li>
</ul>
</li>
</ol>
<p>The top ten countries is an aggregation where we sort the countries by GDP and take the first ten.<br>
It is a conclusion, as such it will be decoupled from the ingestion, which is the writeside. We are going to do it later, on the readside.</p>
<p>It will be eventually consistent with the input, meaning that it may take a while to achieve full consistency with the input from writeside, but it will get there. <em>Eventually</em>.</p>
<p>We can make a drawing out if this. Let’s see.<br>
<img src="https://i.imgur.com/Ovcm69z.png" alt="enter image description here"></p>
<h2 id="domaindrivendesign">2.1 DomainDrivenDesign</h2>
<p>2.1.1<br>
We can start by modeling Domain Driven Design itself!<br>
<img src="https://i.imgur.com/LRW53wH.png" alt="enter image description here"></p>
<p>Now that we have these useful guidelines, we can continue to make a little proof of concept on the test folder:<br>
<img src="https://i.imgur.com/BY8CgCL.png" alt="enter image description here"></p>
<p>2.1.2 Domain services<br>
We just went through with the DomainDrivenDesign building blocks, now we can use another abstraction proposed by DDD, services.</p>
<p>Our domain would need a service that given N countries with their GDP, would rank them and take the first ten.</p>
<p>Let’s apply some TDD.<br>
<img src="https://i.imgur.com/CdUQihX.png" alt="enter image description here"><br>
<img src="https://i.imgur.com/qf3n5XQ.png" alt="enter image description here"></p>
<p>2.1.3 State, Commands, and Events<br>
A <strong>Command</strong> comes to our system, it wants to have consecuences.<br>
It wants to leave a fingerprint on your codebase and your database.<br>
But <strong>Command</strong> is, in fact, a <em>suggestion</em>. We could start calling them <strong>Suggestion</strong>, because <em>what is most important about them</em> is that they can be rejected.<br>
An <strong>Event</strong> is <strong>Command</strong> we did not reject, its consecuence.<br>
We will persist events, make them the cornerstone of our resilience:<br>
as with EventSourcing we can recreate the entire state of our application in case of failure. Our system crashes? No problem. Let it crash. We will recover our state, and we will do so by iterating over every event we stored.<br>
The foundations of our model, the <strong>Event</strong>.<br>
And a State, given an Event, will change. Simple as that.</p>
<p>I got a small citation from a great author on this topic.<br>
Citing Greg Young.</p>
<blockquote>
<p>One way commands dont exist.<br>
Commands can be rejected, or they are valid<br>
and become Events.<br>
… If one way commands existed you could<br>
extract money from an ATM, just by asking<br>
for it. And only after the fact would the ATM<br>
know that your bank account had no funds,<br>
and then, what then! It would grow a pair<br>
of legs and chase you over the street.</p>
</blockquote>
<p><img src="https://i.imgur.com/cBxSmOr.png" alt="enter image description here"><br>
Our application, implemented:<br>
<img src="https://i.imgur.com/Dz7QlMG.png" alt="enter image description here"></p>
<p>2.1.4 Actor Model<br>
Domai</p>
</div>
</body>

</html>
